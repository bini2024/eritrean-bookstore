<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eritrean Bookstore</title>
  <meta name="description" content="Discover and purchase the best Eritrean literature online.">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />

  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
   <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-functions-compat.js"></script>
  <style>
    :root {
      --primary: #0044cc;
      --secondary: #0066ff;
      --accent: #ffdd00;
      --bg: #f9f9f9;
      --text: #333;
      --card-bg: #fff;
      --panel-width: 320px;
      --error-color: #d9534f;
      --success-color: #5cb85c;
      --info-color: #5bc0de;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body { font-family: 'Roboto', sans-serif; background: var(--bg); color: var(--text); overflow-x: hidden; }
    header {
      background: var(--primary);
      color: #fff;
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    header h1 { font-size: 1.5rem; }
    header nav ul { list-style: none; display: flex; gap: 1rem; align-items: center; }
    header nav ul li a, header nav ul li button {
      color: #fff;
      text-decoration: none;
      font-weight: bold;
      cursor: pointer;
      background: none;
      border: none;
      font-size: 1rem; /* Match link style */
      font-family: inherit; /* Match link style */
    }
    .cart-button-wrapper { /* Renamed from cart-button for clarity */
      position: relative;
      display: inline-block;
    }
    .cart-count {
      position: absolute;
      top: -8px;
      right: -12px;
      background: var(--accent);
      color: var(--primary);
      border-radius: 50%;
      padding: 2px 6px;
      font-size: 0.75rem;
      font-weight: bold;
    }
    .hero {
      /* Update this URL to your hero image */
      background: url('https://via.placeholder.com/1200x600?text=Eritrean+Bookstore+Hero') no-repeat center/cover;
      background-color: #555; /* Fallback color */
      height: 60vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: white;
      position: relative;
    }
    .hero::after { content: ''; position: absolute; inset: 0; background: rgba(0,0,0,0.4); }
    .hero h2 { font-size: 2.5rem; z-index: 1; margin-bottom: 1rem; }
    .hero .cta .btn { background: var(--accent); color: var(--primary); border: none; padding: 0.75rem 1.5rem; border-radius: 5px; cursor: pointer; transition: background 0.3s; z-index:1; font-size: 1rem; font-weight: bold;}
    .hero .cta .btn:hover { background: #ffe066; }

    .books-section { padding: 2rem 1rem; max-width: 1200px; margin: auto; }
    #booksError { color: var(--error-color); text-align: center; margin-bottom: 1rem; font-weight: bold; }
    .books-header { display: flex; flex-direction: column; align-items: center; gap: 1rem; margin-bottom: 1.5rem; }
    .books-header h2 { font-size: 2rem; color: var(--primary); }
    .books-header input { width: 100%; max-width: 400px; padding: 0.5rem; border: 1px solid #ccc; border-radius: 5px; }

    .books-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px,1fr)); gap: 1.5rem; }
    .book-card {
      background: var(--card-bg);
      border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: transform 0.3s;
    }
    .book-card:hover { transform: translateY(-5px); }
     /* Added object-position for consistent look if images vary */
    .book-card img { width: 100%; height: 250px; object-fit: cover; object-position: center; background-color: #eee; /* Placeholder bg */ }
    .book-info { padding: 1rem; flex-grow: 1; display: flex; flex-direction: column; justify-content: space-between; }
    .book-info h3 { font-size: 1.1rem; color: var(--primary); margin-bottom: 0.5rem; }
    .book-info p { margin-bottom: 0.5rem; }
    .book-info .controls { display: flex; align-items: center; gap: 0.5rem; margin-top: 0.5rem; }
    .book-info .qty { width: 60px; padding: 0.35rem; text-align: center; border: 1px solid #ccc; border-radius: 5px; }
    .book-info .add-btn { background: var(--primary); color: white; border: none; padding: 0.5rem; border-radius: 5px; cursor: pointer; flex-shrink: 0; transition: background 0.3s; }
    .book-info .add-btn:disabled { background: #ccc; cursor: not-allowed; }

    /* Cart panel */
    .cart-panel {
      position: fixed;
      top: 0;
      right: calc(-1 * var(--panel-width) - 10px); /* Hide fully */
      width: var(--panel-width);
      max-width: 90vw; /* Prevent excessive width on small screens */
      height: 100%;
      background: var(--card-bg);
      box-shadow: -4px 0 8px rgba(0,0,0,0.2);
      transition: right 0.3s ease-in-out;
      z-index: 2000;
      display: flex;
      flex-direction: column;
    }
    .cart-panel.open { right: 0; }
    .cart-header { padding: 1rem; background: var(--primary); color: white; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
    .cart-header h2 { margin: 0; font-size: 1.25rem; }
    .cart-close { background: transparent; border: none; color: white; font-size: 1.75rem; cursor: pointer; line-height: 1; padding: 0 0.5rem;}
    .cart-content { flex-grow: 1; overflow-y: auto; padding: 1rem; }
    .cart-item { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; gap: 0.5rem; border-bottom: 1px solid #eee; padding-bottom: 0.75rem; }
    .cart-item .item-info { flex-grow: 1; font-size: 0.9rem;}
    .cart-item .item-info strong { display: block; margin-bottom: 0.25rem; font-size: 1rem;}
    .cart-item .item-controls { display: flex; align-items: center; gap: 0.3rem; flex-shrink: 0;}
    .cart-item .item-controls button { background: #eee; border: 1px solid #ccc; padding: 0.25rem 0.5rem; border-radius: 5px; cursor: pointer; font-size: 0.9rem; min-width: 25px; text-align: center; }
    .cart-item .item-controls .remove-btn { background: #fdd; color: var(--error-color); border-color: var(--error-color);}
    .cart-item .item-qty { padding: 0 0.5rem; font-weight: bold; min-width: 20px; text-align: center; }

    .cart-footer { padding: 1rem; border-top: 1px solid #ddd; flex-shrink: 0; }
    .cart-footer p { margin-bottom: 1rem; font-weight: bold; font-size: 1.1rem; }
    .cart-footer .checkout-btn { width: 100%; padding: 0.75rem; font-size: 1rem; background: var(--primary); color: white; border: none; border-radius: 5px; cursor: pointer; transition: background 0.3s; }
    .cart-footer .checkout-btn:hover { background: var(--secondary); }
    .cart-footer .checkout-btn:disabled { background: #ccc; cursor: not-allowed; }
    #orderStatus { margin-top: 1rem; font-weight: bold; }
    #orderStatus.success { color: var(--success-color); }
    #orderStatus.error { color: var(--error-color); }
     #orderStatus.info { color: var(--info-color); } /* Style for processing status */


    /* Overlay */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.4);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s, visibility 0.3s;
      z-index: 1500;
    }
    .overlay.show { opacity: 1; visibility: visible; }

    /* Focus Styles for Accessibility */
    a:focus, button:focus, input:focus {
      outline: 2px solid var(--secondary);
      outline-offset: 2px;
      box-shadow: 0 0 0 3px rgba(0, 102, 255, 0.3); /* Optional softer glow */
    }
    /* Remove default outline if custom is applied */
    a, button, input { outline: none; }


    @media (max-width: 600px) {
      header h1 { font-size: 1.2rem; }
      .hero h2 { font-size: 2rem; }
      .books-grid { grid-template-columns: repeat(auto-fill, minmax(150px,1fr)); }
      .book-card img { height: 200px; }
      /* Consider making cart panel full width or wider on small screens */
      /* .cart-panel { width: 90vw; --panel-width: 90vw; } */
    }

  .footer {
    background-color: #111;
    color: #ddd;
    padding: 20px 15px;
    font-family: Arial, sans-serif;
    margin-top: 3rem; /* Ensure space above footer */
  }
  .footer-container {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    gap: 20px;
    max-width: 1000px;
    margin: auto;
  }
  .footer-col { flex: 1 1 200px; }
  .footer-col h4 { color: #fff; margin-bottom: 10px; font-size: 16px; }
  .footer-col p, .footer-col ul, .footer-col a { color: #bbb; font-size: 13px; text-decoration: none; line-height: 1.4; }
  .footer-col ul { list-style: none; padding: 0; }
  .footer-col ul li { margin-bottom: 6px; }
  .footer-col a:hover { color: #fff; }
  .social-icons a { font-size: 16px; margin-right: 8px; color: #bbb; }
  .social-icons a:hover { color: #fff; }
  .footer-bottom { text-align: center; margin-top: 20px; border-top: 1px solid #333; padding-top: 10px; font-size: 12px; color: #999; }

  </style>
</head>
<body>
  <header>
    <h1>Eritrean Bookstore</h1>
    <nav>
      <ul>
        <li><a href="#books">Books</a></li>
        <li class="cart-button-wrapper">
          <button type="button" id="cartToggleButton" aria-label="Toggle shopping cart">
              Cart
              <span class="cart-count" id="cart-count" aria-live="polite">0</span>
          </button>
        </li>
      </ul>
    </nav>
  </header>

  <div class="hero">
    <h2>Discover the Best Eritrean Books</h2>
    <div class="cta"><button class="btn" onclick="scrollToElement('books')">Shop Now</button></div>
  </div>

  <section id="books" class="books-section">
    <div class="books-header">
      <h2>Our Collection</h2>
      <input type="search" id="searchInput" placeholder="Search books by title...">
    </div>
    <div id="booksError"></div>
    <div class="books-grid" id="booksGrid">
        <p>Loading books...</p>
    </div>
  </section>

  <div class="overlay" id="cartOverlay"></div>
  <aside class="cart-panel" id="cartPanel" aria-labelledby="cartHeading">
    <div class="cart-header">
      <h2 id="cartHeading">Your Cart</h2>
      <button class="cart-close" id="cartCloseButton" aria-label="Close cart">&times;</button>
    </div>
    <div class="cart-content" id="cartItems">
        <p>Your cart is empty.</p>
    </div>
    <div class="cart-footer">
      <p>Total: $<span id="cartTotal">0.00</span></p>
      <button class="checkout-btn" id="checkoutBtn">Checkout</button>
      <p id="orderStatus"></p>
    </div>
  </aside>

  <footer class="footer">
    <div class="footer-container">
      <div class="footer-col about">
        <h4>About Eritrean Bookstore</h4>
        <p>We curate Eritrea’s finest literary works—celebrating culture, history, and heritage through timeless books and stories.</p>
      </div>
      <div class="footer-col links">
        <h4>Quick Links</h4>
        <ul>
          <li><a href="#books">Browse Books</a></li>
          <li><a href="#contact">Contact Us</a></li>
          <li><a href="admin.html">Admin Panel</a></li>
        </ul>
      </div>
      <div class="footer-col contact" id="contact">
        <h4>Connect With Us</h4>
        <p>Email: <a href="mailto:contact@eritreanbookstore.com">contact@eritreanbookstore.com</a></p>
        <div class="social-icons">
          <a href="#" aria-label="Facebook" title="Facebook"><i class="fab fa-facebook-f"></i></a>
          <a href="#" aria-label="Twitter" title="Twitter"><i class="fab fa-twitter"></i></a>
          <a href="#" aria-label="Instagram" title="Instagram"><i class="fab fa-instagram"></i></a>
        </div>
      </div>
    </div>
    <div class="footer-bottom">
       <p>&copy; <span id="currentYear">2025</span> <strong>Eritrean Bookstore</strong>. All rights reserved.</p>
    </div>
  </footer>
  <!-- Include these BEFORE this script, e.g. in your <head> or just before </body>:
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
<script src="https://js.stripe.com/v3/"></script>
-->

<script>
document.addEventListener('DOMContentLoaded', () => {
  // --- Firebase Configuration ---
  const firebaseConfig = {
    apiKey: "AIzaSyBE3_ivAE2WFXQ3H8m1OWqM9APvRrI-Ac0",
    authDomain: "eritrean-bookstore.firebaseapp.com",
    projectId: "eritrean-bookstore",
    storageBucket: "eritrean-bookstore.appspot.com",
    messagingSenderId: "645911365846",
    appId: "1:645911365846:web:5cd71799c6969bcaa1a177"
  };

  // Verify Firebase SDK is loaded
  if (typeof firebase === 'undefined' || typeof firebase.initializeApp !== 'function') {
    console.error("Firebase SDK not loaded. Check your <script> tags.");
    return;
  }

  // Initialize Firebase
  let db;
  try {
    const app = firebase.initializeApp(firebaseConfig);
    db = firebase.firestore();
  } catch (err) {
    console.error("Firebase initialization error:", err);
    return;
  }

  // --- Constants ---
  const BOOKS_COLLECTION     = 'books';
  const ORDERS_COLLECTION    = 'orders';
  const ORDER_STATUS_PENDING = 'pending';
  const DEBOUNCE_DELAY       = 300; // ms

  // --- Global State ---
  let allBooks = [];
  let cart = [];
  try {
    const stored = JSON.parse(localStorage.getItem('cart'));
    cart = Array.isArray(stored) ? stored : [];
  } catch {
    cart = [];
  }
  let searchTimeout;

  // --- DOM Element Caching ---
  const booksGrid         = document.getElementById('booksGrid');
  const searchInput       = document.getElementById('searchInput');
  const cartPanel         = document.getElementById('cartPanel');
  const cartOverlay       = document.getElementById('cartOverlay');
  const cartItemsContainer= document.getElementById('cartItems');
  const cartTotalEl       = document.getElementById('cartTotal');
  const cartCountEl       = document.getElementById('cart-count');
  const checkoutBtn       = document.getElementById('checkoutBtn');
  const orderStatusEl     = document.getElementById('orderStatus');
  const cartToggleButton  = document.getElementById('cartToggleButton');
  const cartCloseButton   = document.getElementById('cartCloseButton');
  const booksErrorEl      = document.getElementById('booksError');
  const currentYearEl     = document.getElementById('currentYear');
  const paymentForm       = document.getElementById('payment-form');
  const paymentElement    = document.getElementById('payment-element');
  const paymentMessage    = document.getElementById('payment-message');
  const paymentSubmitButton = paymentForm
    ? paymentForm.querySelector('button[type="submit"]')
    : null;

  // --- Stripe Initialization ---
  // TODO: Replace with your real publishable key
  const stripe = Stripe('pk_test_YOUR_PUBLISHABLE_KEY');
  let paymentIntentClientSecret = null;
  let elements;

  // --- Utility Functions ---
  function scrollToElement(id) {
    const el = document.getElementById(id);
    if (el) el.scrollIntoView({ behavior: 'smooth' });
  }

  function toggleCart() {
    const isOpen = cartPanel.classList.contains('open');
    cartPanel.classList.toggle('open');
    cartOverlay.classList.toggle('show');
    if (!isOpen) {
      renderCart();
      if (paymentForm)      paymentForm.style.display = 'none';
      if (paymentMessage)   paymentMessage.textContent = '';
    }
  }

  function saveCart() {
    localStorage.setItem('cart', JSON.stringify(cart));
    updateCartCount();
    checkoutBtn.disabled = cart.length === 0;
  }

  function updateCartCount() {
    const count = Array.isArray(cart)
      ? cart.reduce((sum, item) => sum + (item.quantity || 0), 0)
      : 0;
    cartCountEl.textContent = count;
  }

  function debounce(fn, delay) {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(fn, delay);
  }

  function escapeHTML(str) {
    if (typeof str !== 'string') return str;
    const div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
  }

        // --- Core Application Logic ---

        // Fetch & Render Books
        async function fetchBooks() {
          booksErrorEl.textContent = '';
           // Display a loading message
          booksGrid.innerHTML = '<p>Loading books...</p>';
          try {
            // Fetch books, potentially add ordering later if needed
             const snapshot = await db.collection(BOOKS_COLLECTION).get(); // v8 get()

            if (snapshot.empty) {
                booksGrid.innerHTML = '<p>No books found in the collection.</p>';
                allBooks = [];
                return;
            }

            // v8 snapshot.docs mapping is the same
            allBooks = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            renderBooks(allBooks);

          } catch (error) {
            console.error("Error fetching books:", error);
            booksErrorEl.textContent = 'Failed to load books. Please check connection or Firestore configuration/rules.';
            booksGrid.innerHTML = ''; // Clear loading message on error
          }
        }

        function renderBooks(bookList) {
          booksGrid.innerHTML = ''; // Clear current grid content

          if (!Array.isArray(bookList)) {
              booksGrid.innerHTML = '<p>Error: Book data format incorrect.</p>';
              console.error("renderBooks received invalid data:", bookList);
              return;
          }


          if (bookList.length === 0 && searchInput.value.trim() !== '') {
               booksGrid.innerHTML = '<p>No books match your search.</p>';
          } else if (bookList.length === 0 && allBooks.length === 0 && booksErrorEl.textContent === '') {
               // Only show 'No books available' if the initial fetch was successful but returned no books
               booksGrid.innerHTML = '<p>No books available at the moment.</p>';
          } else if (bookList.length === 0 && allBooks.length > 0 && searchInput.value.trim() === '') {
              // This case should ideally not happen if allBooks is not empty and no search is active
               booksGrid.innerHTML = '<p>Error displaying books.</p>'; // Fallback message
          }
           else {
            bookList.forEach(book => {
              const card = document.createElement('div');
              card.className = 'book-card';
              // Ensure stock is a number, default to 0 if not valid
              const stock = typeof book.stock === 'number' ? book.stock : 0;
              const isOutOfStock = stock <= 0;
               // Ensure price is a number, default to 0 if not valid
              const price = typeof book.price === 'number' ? book.price : 0;


              card.innerHTML = `
                <img src="${book.imgURL || 'placeholder.jpg'}" alt="${escapeHTML(book.title || 'Untitled Book')}" loading="lazy">
                <div class="book-info">
                  <div>
                    <h3>${escapeHTML(book.title || 'Untitled Book')}</h3>
                    <p>$${price.toFixed(2)}</p>
                  </div>
                  <div class="controls">
                    <input type="number" min="1" max="${stock}" value="1" class="qty" id="qty-${book.id}" aria-label="Quantity for ${escapeHTML(book.title || 'Untitled Book')}" ${isOutOfStock ? 'disabled' : ''}>
                    <button class="add-btn" data-book-id="${book.id}" ${isOutOfStock ? 'disabled' : ''}>
                      ${isOutOfStock ? 'Out of Stock' : 'Add to Cart'}
                    </button>
                  </div>
                </div>`;

              const addButton = card.querySelector('.add-btn');
              if (addButton && !isOutOfStock) {
                  addButton.addEventListener('click', () => {
                      const qtyInput = card.querySelector(`#qty-${book.id}`);
                      // Ensure quantity is a valid positive integer
                      const quantity = parseInt(qtyInput.value, 10);
                      if (isNaN(quantity) || quantity < 1) {
                           alert('Please enter a valid quantity.');
                           qtyInput.value = '1'; // Reset input
                           return;
                      }
                      if (quantity > stock) {
                           alert(`Cannot add ${quantity}. Only ${stock} "${book.title}" available.`);
                            qtyInput.value = '1'; // Reset input
                           return;
                      }

                      addToCart(book.id, quantity);
                       // Provide visual feedback for adding to cart
                       addButton.textContent = 'Added!';
                       addButton.disabled = true; // Disable temporarily
                       setTimeout(() => {
                           addButton.textContent = 'Add to Cart';
                           addButton.disabled = false; // Re-enable
                           qtyInput.value = '1'; // Reset quantity input
                        }, 1000); // Show 'Added!' for 1 second

                  });
              }
              booksGrid.appendChild(card);
            });
          }
        }

        // Search functionality
        function handleSearch() {
            const query = searchInput.value.toLowerCase().trim();
            // Filter the globally stored allBooks array
            const filteredBooks = allBooks.filter(book =>
                book.title && typeof book.title === 'string' && book.title.toLowerCase().includes(query) // Ensure book.title exists and is string
            );
            renderBooks(filteredBooks);
        }

        // Cart Functions
        function addToCart(bookId, quantityToAdd) {
            const book = allBooks.find(b => b.id === bookId);
            // Validate book exists, has a valid price, and enough stock
            if (!book || typeof book.price !== 'number' || typeof book.stock !== 'number' || book.stock <= 0) {
                 console.error("Attempted to add invalid or out-of-stock book:", bookId, book);
                alert("Error: Could not add item. Book data is missing or out of stock.");
                return;
            }
             if (quantityToAdd < 1) {
                 console.warn("Attempted to add quantity less than 1:", quantityToAdd);
                 return;
             }

            const existingCartItemIndex = cart.findIndex(item => item.id === bookId);
            let currentCartQty = 0;

            if (existingCartItemIndex > -1) {
                currentCartQty = cart[existingCartItemIndex].quantity;
            }

            const potentialNewTotalQty = currentCartQty + quantityToAdd;

            // Client-side stock check (subject to race conditions)
             // A truly secure check happens server-side during checkout
            if (book.stock < potentialNewTotalQty) {
                alert(`Sorry, only ${book.stock} "${book.title}" items available in total. You already have ${currentCartQty} in your cart.`);
                return;
            }

            if (existingCartItemIndex > -1) {
                cart[existingCartItemIndex].quantity = potentialNewTotalQty;
            } else {
                // Create a new item in the cart. Store necessary info.
                // The price stored here is for display/initial calc only.
                // This price MUST be re-verified server-side at checkout.
                cart.push({
                    id: bookId,
                    title: book.title,
                    price: book.price, // Store price here, BUT VALIDATE SERVER-SIDE at checkout
                    quantity: quantityToAdd,
                    imgURL: book.imgURL // Store image URL for cart display
                });
            }

            saveCart();
             // No need to renderCart here, it's rendered when the panel opens
        }

        function renderCart() {
            cartItemsContainer.innerHTML = ''; // Clear current cart content
            let currentTotal = 0;
            orderStatusEl.textContent = ''; // Clear previous order status message

            if (cart.length === 0) {
                cartItemsContainer.innerHTML = '<p>Your cart is empty.</p>';
                cartTotalEl.textContent = '0.00';
                checkoutBtn.disabled = true;
                return;
            }

            // Filter out potentially invalid items or items with quantity 0 just in case
            cart = cart.filter(item => item && item.id && typeof item.quantity === 'number' && item.quantity > 0);

            if (cart.length === 0) { // Re-check if filtering removed all items
                 cartItemsContainer.innerHTML = '<p>Your cart is empty.</p>';
                cartTotalEl.textContent = '0.00';
                checkoutBtn.disabled = true;
                saveCart(); // Save the now empty cart
                return;
            }


            cart.forEach(item => {
                // Ensure price is a number before calculation
                const price = typeof item.price === 'number' ? item.price : 0;
                const itemTotal = price * item.quantity;
                currentTotal += itemTotal;
                // Find the book in the fetched list to check current stock (for warning display)
                 const bookInStock = allBooks.find(b => b.id === item.id)?.stock || 0;


                const div = document.createElement('div');
                div.className = 'cart-item';
                 // Use escapeHTML for title
                div.innerHTML = `
                   <img src="${item.imgURL || 'placeholder.jpg'}" alt="${escapeHTML(item.title || 'Item')}" style="width: 40px; height: auto; vertical-align: middle; margin-right: 8px; border-radius: 4px;">
                  <div class="item-info">
                    <strong>${escapeHTML(item.title || 'Untitled Item')}</strong>
                    <span>$${price.toFixed(2)} x ${item.quantity} = $${itemTotal.toFixed(2)}</span>
                    ${item.quantity > bookInStock ? `<br><small style="color:red; font-weight:bold;">Warning: Qty exceeds available stock (${bookInStock})</small>` : ''}
                  </div>
                  <div class="item-controls">
                    <button onclick="updateQty('${item.id}', ${item.quantity - 1})" aria-label="Decrease quantity of ${escapeHTML(item.title || 'item')}">-</button>
                    <span class="item-qty" aria-live="polite">${item.quantity}</span>
                     <button onclick="updateQty('${item.id}', ${item.quantity + 1})" ${item.quantity >= bookInStock ? 'disabled' : ''} aria-label="Increase quantity of ${escapeHTML(item.title || 'item')}">+</button>
                    <button class="remove-btn" onclick="removeItem('${item.id}')" aria-label="Remove ${escapeHTML(item.title || 'item')} from cart">&times;</button>
                  </div>`;
                cartItemsContainer.appendChild(div);
            });

            cartTotalEl.textContent = currentTotal.toFixed(2);
            checkoutBtn.disabled = false; // Re-enable if cart is not empty
        }

        function updateQty(id, newQty) {
            // Ensure newQty is a valid number
            newQty = parseInt(newQty, 10);
            if (isNaN(newQty) || newQty < 0) {
                 console.warn("Invalid new quantity:", newQty);
                 return;
            }

             // If new quantity is 0, just remove the item
            if (newQty === 0) {
                return removeItem(id);
            }

            const book = allBooks.find(b => b.id === id);
            const stock = book?.stock || 0; // Get current stock from the fetched list

             // Check against current stock
            if (newQty > stock) {
                alert(`Sorry, only ${stock} items available for "${book?.title || 'this item'}".`);
                return; // Prevent updating quantity above stock
            }

            cart = cart.map(item =>
                item.id === id ? { ...item, quantity: newQty } : item
            ); // Do not filter out quantity 0 here, let removeItem handle it

            saveCart();
            renderCart(); // Re-render cart after update
        }

        function removeItem(id) {
            cart = cart.filter(item => item.id !== id);
            saveCart();
            renderCart(); // Re-render cart after removal
        }

        // --- Initialize Stripe Payment Element ---
        // Call this after successfully getting the client secret from the Cloud Function
        async function initializePaymentElement(clientSecret) {
            if (!clientSecret) {
                console.error("Client secret is missing for payment element initialization.");
                // Display an error message to the user
                if (paymentMessage) {
                    paymentMessage.textContent = "Unable to set up payment form. Please try again.";
                    paymentMessage.style.color = 'red';
                }
                if (paymentForm) paymentForm.style.display = 'none'; // Hide form if init fails
                return null; // Return null if initialization failed
            }

            // Assume you have a div with id="payment-element" in your HTML inside the cart panel
            // Clear previous instances if the user opens/closes the cart or retries
            if (paymentElement) paymentElement.innerHTML = '';
            if (paymentMessage) paymentMessage.textContent = ''; // Clear previous messages


            const appearance = {
                theme: 'stripe', // or 'flat', 'night'
                // You can customize appearance further: https://stripe.com/docs/elements/appearance-api
            };

            // Create a Stripe Elements instance using the client secret
            elements = stripe.elements({ appearance, clientSecret });

            // Create and mount the Payment Element UI
            const paymentElementInstance = elements.create('payment');
            if (paymentElement) {
                paymentElementInstance.mount(paymentElement);
                // Show the payment form if successfully initialized
                 if (paymentForm) paymentForm.style.display = 'block';
                 console.log("Stripe Payment Element mounted.");

                 // Re-enable the payment submit button if it exists
                 if(paymentSubmitButton) paymentSubmitButton.disabled = false;

            } else {
                 console.error("Payment element container #payment-element not found in HTML.");
                 if (paymentMessage) {
                      paymentMessage.textContent = "Payment form container not found in HTML.";
                      paymentMessage.style.color = 'red';
                 }
                 if (paymentForm) paymentForm.style.display = 'none'; // Hide form
                 return null; // Return null if container is missing
            }

            return elements; // Return elements instance for later use in confirmPayment
        }


        // --- Confirm Payment with Stripe ---
        // Called when the user submits the payment form
        async function confirmPayment() {
            if (!paymentIntentClientSecret || !elements) {
                console.error("Client secret or elements not available for payment confirmation.");
                if (paymentMessage) {
                    paymentMessage.textContent = "Payment cannot be confirmed. Missing details.";
                    paymentMessage.style.color = 'red';
                }
                 // Re-enable payment form submit button
                 if(paymentSubmitButton) paymentSubmitButton.disabled = false;
                return;
            }

            // Disable the payment form submission button to prevent double clicks
             if(paymentSubmitButton) paymentSubmitButton.disabled = true;
             if(paymentMessage) {
                 paymentMessage.textContent = 'Processing payment...';
                 paymentMessage.style.color = 'inherit'; // Reset color
             }


            // Use the Stripe.js confirmPayment method to finalize the payment
            const { error: stripeError, paymentIntent } = await stripe.confirmPayment({
                elements, // The elements instance containing the payment form data
                clientSecret: paymentIntentClientSecret, // The client secret received from your Cloud Function
                confirmParams: {
                    // return_url specifies where to redirect the customer after payment confirmation
                    // if required (e.g., 3D Secure). It must be on your domain.
                    // For this example, we'll redirect back to the same page.
                    // In production, you might have a dedicated success page.
                     return_url: window.location.href, // Redirects back to the current page URL
                },
                redirect: 'if_required', // Redirects the user if the payment requires additional action (like 3D Secure)
            });

            if (stripeError) {
                // This point will only be reached if there is an immediate error when
                // confirming the payment. Otherwise, the customer will be redirected.
                if (paymentMessage) {
                    paymentMessage.textContent = stripeError.message; // Display Stripe's user-friendly error message
                    paymentMessage.style.color = 'red';
                }
                console.error("Stripe payment confirmation failed:", stripeError);

                // IMPORTANT: In a real production app, you should ideally inform your server
                // about this failed payment by calling another Cloud Function or sending a fetch request.
                // This would update the order status in Firestore to 'failed_payment'.
                // For this example, we rely on the Stripe webhook to update the order status.

                // Re-enable the payment form submission button
                 if(paymentSubmitButton) paymentSubmitButton.disabled = false;


            } else {
                // Payment succeeded client-side.
                // Note: This does NOT guarantee the payment has been captured or finalized server-side.
                // You MUST rely on Stripe webhooks for final payment confirmation and order fulfillment.
                if (paymentMessage) {
                     paymentMessage.textContent = 'Payment successful! Finalizing order...'; // Updated message
                     paymentMessage.style.color = 'green';
                }
                console.log("Stripe payment confirmation successful (client-side):", paymentIntent);

                // In a real app, you would now wait for the 'payment_intent.succeeded' webhook
                // on your server to fulfill the order (deduct stock, send email, etc.).
                // For this simplified example WITHOUT webhooks:
                // We will clear the cart and update UI based on client-side confirmation,
                // but stock deduction happens via webhook.

                // Clear cart and update UI assuming success (simplification for demo)
                 cart = [];
                 saveCart(); // Saves empty cart to localStorage
                 renderCart(); // Updates cart UI to show empty cart

                 // Update the main order status message
                 orderStatusEl.textContent = 'Payment confirmed. Order is being finalized (check Firestore via webhook).'; // Updated message
                 orderStatusEl.className = 'success';

                 // Do NOT call fetchBooks() here, as stock is updated via webhook server-side
                 // fetchBooks(); // REMOVED

                // Hide the payment form after success
                 if (paymentForm) paymentForm.style.display = 'none';

                // Re-enable the main checkout button
                checkoutBtn.disabled = false;
                checkoutBtn.textContent = 'Checkout';

                 // Optionally redirect the user to an order success page
                 // window.location.href = '/order-success.html?order_id=' + paymentIntent.metadata.order_id; // Example redirect
            }
        }


        // --- Secure Checkout Flow (Initiated by clicking the main Checkout button) ---
        // This function calls the Cloud Function to create the Order and Payment Intent.
        async function handleCheckout() {
            if (cart.length === 0) {
                alert("Your cart is empty.");
                return;
            }

            // Client-Side Validation: Basic check of cart items before sending to backend
            const itemsToProcess = [];
            let hasInvalidItems = false;

            for (const item of cart) {
                if (!item || !item.id || typeof item.quantity !== 'number' || item.quantity <= 0) {
                    alert(`Skipping invalid item in cart.`);
                    console.error("Invalid item found in cart during client-side validation:", item);
                    hasInvalidItems = true;
                    continue; // Skip this invalid item, but continue checking others
                }
                // Only send bookId and quantity to the backend for security
                itemsToProcess.push({
                    bookId: item.id,
                    quantity: item.quantity
                });
            }

            console.log("Data being sent to processOrder function:", itemsToProcess);

            if (itemsToProcess.length === 0) {
                let message = "Your cart is empty.";
                if (hasInvalidItems) {
                     message = "Your cart contains no valid items to checkout.";
                }
                alert(message);
                orderStatusEl.textContent = message;
                orderStatusEl.className = 'error';
                renderCart(); // Re-render in case invalid items were conceptually removed
                checkoutBtn.disabled = false;
                checkoutBtn.textContent = 'Checkout';
                return; // Stop checkout process as there's nothing valid to send
            }

            // If we reached here, itemsToProcess has at least one valid item.
            // Proceed with calling the Cloud Function.

            // Disable the main checkout button and show processing message
            checkoutBtn.disabled = true;
            checkoutBtn.textContent = 'Processing Order...';
            orderStatusEl.textContent = 'Processing your order...';
            orderStatusEl.className = 'info';
            if (paymentMessage) paymentMessage.textContent = ''; // Clear payment messages


            // Prepare data to send in the HTTP request body
            // Send the standard { items: [...] } structure
            const orderData = {
                items: itemsToProcess
                // You can add customer details or shipping info here if needed by the function
            };

            // >>> REPLACE WITH YOUR ACTUAL processOrder CLOUD FUNCTION HTTP TRIGGER URL <<<
            // Get this URL from Firebase Console -> Functions -> Dashboard -> your_function_name
            const cloudFunctionUrl = 'https://us-central1-eritrean-bookstore.cloudfunctions.net/processOrder'; // <-- !!! REPLACE THIS URL AFTER DEPLOYMENT !!!


            try {
                 // --- Call the HTTP Trigger Cloud Function using fetch ---
                 // This call will initiate the order processing, stock check, order document creation,
                 // and Stripe Payment Intent creation on the server.
                 const response = await fetch(cloudFunctionUrl, {
                     method: 'POST', // Use POST method
                     headers: {
                         'Content-Type': 'application/json' // Specify content type is JSON
                     },
                     body: JSON.stringify(orderData) // Send data as a JSON string in the request body
                 });

                // Check if the HTTP response status code indicates success (2xx)
                if (!response.ok) {
                     // If response status is not ok (e.g., 400, 404, 409, 500), it's an HTTP error
                     // Try to parse the error response body if it's JSON (the function sends JSON errors)
                     const errorResponseData = await response.json().catch(() => null); // Attempt to parse JSON, catch parsing errors
                     console.error("HTTP error calling Cloud Function:", response.status, errorResponseData);

                     let errorMessage = `Checkout failed: Server returned status ${response.status}.`;
                     if (errorResponseData && errorResponseData.message) {
                          // If the function sent a JSON error response with a 'message', use that
                         errorMessage = `Checkout failed: ${errorResponseData.message}`;
                     } else if (response.statusText) {
                         // Otherwise, use the HTTP status text if available
                         errorMessage += ` ${response.statusText}`;
                     }

                     // Display the error message to the user
                     orderStatusEl.textContent = errorMessage;
                     orderStatusEl.className = 'error';

                     // Re-fetch books in case of errors after potential partial updates (unlikely with transactions but safe)
                     fetchBooks();


                } else {
                     // HTTP response status is OK (status 200)
                     // Parse the JSON response body from the function
                     const responseData = await response.json();

                     // Check the 'status' field within the function's JSON response payload
                     if (responseData && responseData.status === 'success' && responseData.clientSecret) {
                         // The Cloud Function successfully created the Order document (pending payment)
                         // and the Stripe Payment Intent, and returned the client secret.

                         orderStatusEl.textContent = 'Order created. Please complete payment below.'; // Updated message
                         orderStatusEl.className = 'info';

                         // Store the client secret received from the function
                         paymentIntentClientSecret = responseData.clientSecret;

                         // >>> Initialize and display the Stripe Payment Element using the client secret <<<
                         // This function call will render the secure payment form UI
                         const elementsInstance = await initializePaymentElement(paymentIntentClientSecret);

                         // If the payment element was successfully initialized, add the submit listener
                         if (elementsInstance && paymentForm) {
                             // Remove any previous submit listeners to avoid duplicates
                             // A more robust way might involve tracking listeners or adding once on page load
                             // For this structure, adding it here after successful element init is simpler.

                             // Ensure the listener is added only once
                             if (!paymentForm.dataset.listenerAdded) {
                                 paymentForm.addEventListener('submit', async (e) => {
                                      e.preventDefault(); // Prevent default browser form submission
                                      // Call the function to confirm the payment with Stripe
                                      await confirmPayment();
                                 });
                                 paymentForm.dataset.listenerAdded = 'true'; // Mark listener as added
                                 console.log("Payment form submit event listener added.");
                             }


                         } else {
                             console.error("Failed to initialize Stripe Payment Element.");
                             orderStatusEl.textContent = 'Failed to set up payment form. Please try again.';
                             orderStatusEl.className = 'error';
                             // Re-enable checkout button if payment form setup failed
                             checkoutBtn.disabled = false;
                             checkoutBtn.textContent = 'Checkout';
                         }


                     } else {
                         // Response was 200 OK, but the function's internal 'status' was not 'success'
                         // or the clientSecret was missing in the response payload.
                         console.error("Cloud Function returned success HTTP status but indicates error internally or missing clientSecret:", responseData);
                         orderStatusEl.textContent = (responseData && responseData.message) ? responseData.message : 'Failed to initiate payment process. Check logs.';
                         orderStatusEl.className = 'error';
                         fetchBooks(); // Re-fetch books in case of unexpected state
                         // Re-enable checkout button
                         checkoutBtn.disabled = false;
                         checkoutBtn.textContent = 'Checkout';
                     }
                }

            } catch (error) {
                // Handle network errors or issues during the fetch call itself, or during JSON parsing
                console.error("Error during fetch call or parsing response:", error);
                orderStatusEl.textContent = 'A network error occurred during checkout initiation. Please try again.';
                orderStatusEl.className = 'error';
                 // Re-enable checkout button on fetch error
                checkoutBtn.disabled = false;
                checkoutBtn.textContent = 'Checkout';
            }
            // Note: The main checkoutBtn is re-enabled either in the error handlers above
            // or after the payment confirmation process is complete in confirmPayment.
            // The finally block from the original simple checkout is less relevant here as the flow continues to payment.
        }


        // --- Event Listeners ---
        cartToggleButton.addEventListener('click', toggleCart);
        cartCloseButton.addEventListener('click', toggleCart);
        cartOverlay.addEventListener('click', toggleCart);
        // The main checkoutBtn click initiates the process of getting the client secret
        checkoutBtn.addEventListener('click', handleCheckout);

        // Note: The payment form submission listener is added *after* the client secret is successfully received and the payment element is initialized in handleCheckout.


        // Add event listener for search input with debounce
        searchInput.addEventListener('input', () => {
            debounce(handleSearch, DEBOUNCE_DELAY);
        });

        // --- Initial Load ---
        // Update copyright year dynamically
        if (currentYearEl) {
            currentYearEl.textContent = new Date().getFullYear();
        }
        // Load cart from local storage on page load and update count
        updateCartCount();
        // Load books from Firestore on page load
        fetchBooks();
        // checkoutBtn disabled state is handled by saveCart() call above based on initial cart state


        // --- Make necessary functions globally available for inline HTML handlers ---
        // Note: Using addEventListener is generally preferred over inline handlers (onclick="...").
        // Keeping these for compatibility with your HTML structure if you use them.
        window.updateQty = updateQty;
        window.removeItem = removeItem;
        window.scrollToElement = scrollToElement; // Keep if hero button uses onclick
        window.handleCheckout = handleCheckout; // Ensure this is assigned if you use onclick="handleCheckout()"

        // You might need initializePaymentElement or confirmPayment globally if called from HTML
        // window.initializePaymentElement = initializePaymentElement;
        // window.confirmPayment = confirmPayment; // Only if called directly via onclick


    } catch (initError) {
        // Catch potential errors during Firebase SDK or Stripe SDK initialization or script loading
        console.error("Store initialization failed:", initError);
         const errorMessage = 'Failed to initialize the store. Ensure Firebase and Stripe SDK scripts are in <head> and configurations are correct. Check console for details.';
         // Display error message on the page
         if(booksErrorEl) {
             booksErrorEl.textContent = errorMessage;
         }
         // Clear loading indicators and disable interactive elements if initialization fails
         if(booksGrid) {
              booksGrid.innerHTML = '';
         }
          if(checkoutBtn) {
             checkoutBtn.disabled = true;
             checkoutBtn.textContent = 'Checkout Unavailable';
          }
           if(cartToggleButton) {
             cartToggleButton.disabled = true;
           }
           if(searchInput) {
              searchInput.disabled = true;
           }
           // Update cart panel elements with error message
            if(cartItemsContainer) cartItemsContainer.innerHTML = '<p>Store features unavailable.</p>';
            if(cartTotalEl) cartTotalEl.textContent = '0.00';
            if(cartCountEl) cartCountEl.textContent = '0';
             if(orderStatusEl) {
                 orderStatusEl.textContent = 'Store initialization failed.';
                 orderStatusEl.className = 'error';
             }
             // Hide payment form if it exists
             if (paymentForm) paymentForm.style.display = 'none';
             if (paymentMessage) {
                  paymentMessage.textContent = 'Payment unavailable.';
                  paymentMessage.style.color = 'red';
             }


    } // End of Firebase/Stripe initialization try/catch


  </script>


</body>
</html>
